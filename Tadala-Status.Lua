--Deu Certo Ze Ruela!































































































































































































--[[
    Discord Webhook Autom√°tico para vBot OTC Tibia
    ==============================================
    
    Prop√≥sito: Enviar notifica√ß√µes autom√°ticas do status do personagem para o Discord
    √öltima modifica√ß√£o: 2024-12-19
    Autor: vBot Team, Souled Scripts
    
    Funcionalidades AUTOM√ÅTICAS:
    - Status peri√≥dico (a cada 5 minutos)
    - Level Up (detec√ß√£o autom√°tica)
    - Morte (detec√ß√£o autom√°tica)
]]

-- Configura√ß√£o do webhook
local webhook = "https://discord.com/api/webhooks/1389376128262738210/OxPtoOqpkgGSwH5ARqNYGSg26gbpXx0Eh5gtZYZgD2W2UStWZz5UxSjsoQCWZ28Mwua-"

-- Dados padr√£o do bot
local default_data = {
    username = "vBot Status",
}

-- Configura√ß√£o do embed
local embed = {
    color = 10038562, -- Cor vermelha
    footer = {
        text = "Tadala-Scripts - (Criador Souled-Scripts)",
    },
}

-- Cache de timestamps para controle de cooldown
local discordTimes = {}

-- Vari√°veis para controle autom√°tico
local lastLevel = 0
local lastHP = 100
local isDead = false
local levelStartTime = 0 -- Tempo quando come√ßou o level atual
local levelHistory = {} -- Hist√≥rico de tempos de level up

-- Fun√ß√£o de callback para resultado HTTP
function onHTTPResult(data, err)
    if err then
        print("Discord Webhook Error: " .. err)
    else
        print("Discord Webhook: Mensagem enviada com sucesso!")
    end
end

-- Fun√ß√£o principal para enviar webhook
function sendDiscordWebhook(data)
    local id = data.id
    if id then
        local dTime = discordTimes[id]
        if dTime and os.time() < dTime then 
            return 
        end
        discordTimes[id] = os.time() + (data.delayed and data.delayed or 10)
    end

    -- Adicionar hor√°rio de envio √† mensagem
    local messageWithTime = data.message
    if not messageWithTime:find("Hor√°rio:") then
        messageWithTime = messageWithTime .. " | Hor√°rio: " .. getCurrentTime()
    end

    local dEmbed = embed
    if data.color then 
        dEmbed.color = data.color 
    end
    
    dEmbed.title = "**" .. data.title .. "**"
    dEmbed.fields = {
        {
            name = "Nome: ",
            value = data.name,
        },
        {
            name = "Mensagem",
            value = messageWithTime,
        }
    }

    local dataSend = default_data
    dataSend.embeds = { dEmbed }
    
    HTTP.postJSON(webhook, dataSend, onHTTPResult)
end

-- Fun√ß√£o para formatar posi√ß√£o
function formatPosition(pos)
    if not pos then return "Desconhecida" end
    return string.format("X: %d, Y: %d, Z: %d", pos.x, pos.y, pos.z)
end

-- Fun√ß√£o para obter informa√ß√µes do servidor
function getServerInfo()
    local worldName = g_game.getWorldName()
    
    if worldName then
        return worldName
    else
        return "Desconhecido"
    end
end

-- Fun√ß√£o para obter stamina atual
function getStaminaInfo()
    local stamina = g_game.getLocalPlayer():getStamina()
    if stamina then
        -- Converter minutos para horas
        local hours = math.floor(stamina / 60)
        local minutes = stamina % 60
        
        -- Se menos de 1 hora, mostrar apenas minutos
        if hours == 0 then
            return string.format("%dm", minutes)
        else
            return string.format("%dh %dm", hours, minutes)
        end
    else
        return "N/A"
    end
end

-- Fun√ß√£o para formatar tempo em formato leg√≠vel
function formatTime(seconds)
    if seconds < 60 then
        return string.format("%ds", seconds)
    elseif seconds < 3600 then
        local minutes = math.floor(seconds / 60)
        local secs = seconds % 60
        return string.format("%dm %ds", minutes, secs)
    else
        local hours = math.floor(seconds / 3600)
        local minutes = math.floor((seconds % 3600) / 60)
        return string.format("%dh %dm", hours, minutes)
    end
end

-- Fun√ß√£o para calcular tempo m√©dio de level up
function calculateAverageLevelTime()
    if #levelHistory == 0 then return 0 end
    
    local totalTime = 0
    for _, entry in ipairs(levelHistory) do
        totalTime = totalTime + entry.time
    end
    
    return math.floor(totalTime / #levelHistory)
end

-- Fun√ß√£o para obter hor√°rio atual formatado
function getCurrentTime()
    local time = os.date("*t")
    return string.format("%02d:%02d:%02d", time.hour, time.min, time.sec)
end

-- MACRO 1: Status peri√≥dico autom√°tico (a cada 10 minutos)
macro(600000, function() -- Executa a cada 10 minutos
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    -- Verificar status do CaveBot
    local cavebotStatus = "‚ùå Inativo"
    if CaveBot.isOn() then
        cavebotStatus = "‚úÖ Ativo"
    end
    
    -- Verificar status do Target
    local targetStatus = "‚ùå Inativo"
    if TargetBot.isOn() then
        targetStatus = "‚úÖ Ativo"
    end
    
    -- Verificar se est√° em √°rea PZ usando fun√ß√£o isInPz()
    local pzStatus = "‚ùå PZ"
    if isInPz() then
        pzStatus = "‚úÖ PZ"
    end
    

    
    -- Calcular tempo m√©dio de level up
    local avgLevelTime = "N/A"
    if #levelHistory > 0 then
        local avgSeconds = calculateAverageLevelTime()
        avgLevelTime = formatTime(avgSeconds)
    end
    
    local data = {
        title = 'Status do Personagem',
        name = player:getName(),
        message = string.format('**üìä Informa√ß√µes Gerais:**\n‚Ä¢ Level: %d\n‚Ä¢ Servidor: %s\n‚Ä¢ Posi√ß√£o: %s\n‚Ä¢ Stamina: %s\n\n**ü§ñ Status dos Bots:**\n‚Ä¢ CaveBot: %s\n‚Ä¢ Target: %s\n‚Ä¢ PZ: %s\n\n**‚è±Ô∏è Estat√≠sticas:**\n‚Ä¢ Tempo m√©dio level: %s', 
            player:getLevel(),
            getServerInfo(),
            formatPosition(player:getPosition()),
            getStaminaInfo(),
            cavebotStatus,
            targetStatus,
            pzStatus,
            avgLevelTime),
        id = "status",
        delayed = 600, -- 10 minutos
        color = 0x0099FF -- Azul
    }
    sendDiscordWebhook(data)
end)

-- MACRO 2: Detec√ß√£o autom√°tica de Level Up
macro(1000, function() -- Executa a cada 1 segundo
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    local currentLevel = player:getLevel()
    
    -- Se o level aumentou
    if currentLevel > lastLevel and lastLevel > 0 then
        -- Calcular tempo do level up
        local currentTime = os.time()
        local timeToLevel = currentTime - levelStartTime
        local timeToLevelFormatted = formatTime(timeToLevel)
        
        -- Calcular estimativa para pr√≥ximo level
        local nextLevelEstimate = ""
        if #levelHistory > 0 then
            local avgTime = calculateAverageLevelTime()
            local nextLevelTime = currentTime + avgTime
            nextLevelEstimate = string.format(" | Pr√≥ximo level estimado: %s", formatTime(avgTime))
        end
        
        -- Adicionar ao hist√≥rico
        table.insert(levelHistory, {level = lastLevel, time = timeToLevel})
        if #levelHistory > 5 then -- Manter apenas os √∫ltimos 5 levels
            table.remove(levelHistory, 1)
        end
        
        local data = {
            title = 'Level Up!',
            name = player:getName(),
            message = string.format('**üéâ Parab√©ns! Voc√™ chegou ao level %d!**\n\n**üìä Detalhes:**\n‚Ä¢ Servidor: %s\n‚Ä¢ Tempo para level: %s%s', 
                currentLevel, getServerInfo(), timeToLevelFormatted, nextLevelEstimate),
            id = "level_up",
            delayed = 0, -- Sem delay para level up
            color = 0x00FF00 -- Verde
        }
        sendDiscordWebhook(data)
        
        -- Iniciar contagem para o pr√≥ximo level
        levelStartTime = currentTime
    end
    
    lastLevel = currentLevel
end)

-- Vari√°veis para capturar informa√ß√µes da morte
local lastAttacker = nil
local lastAttackTime = 0
local recentAttackers = {} -- Lista dos √∫ltimos atacantes do server log
local serverLogBuffer = {} -- Buffer das √∫ltimas 10 linhas do server log

-- Callback para capturar danos do server log
onTextMessage(function(mode, text)
    if mode == 22 then -- Server log
        -- DEBUG: Log todas as mensagens do server log
        print("DEBUG Server Log: " .. text)
        
        -- Adicionar ao buffer das √∫ltimas 10 linhas
        table.insert(serverLogBuffer, text)
        if #serverLogBuffer > 10 then
            table.remove(serverLogBuffer, 1) -- Remove a linha mais antiga
        end
        
        -- Capturar mensagens de dano
        local damage, attackerName = text:match("You lose (%d+) hitpoints due to an attack by ([^.]+)")
        if attackerName then
            print("DEBUG: Capturou ataque - Dano: " .. damage .. " | Atacante: " .. attackerName)
            
            -- Adicionar √† lista de atacantes recentes
            table.insert(recentAttackers, {name = attackerName, time = os.time(), damage = tonumber(damage)})
            
            -- Manter apenas os √∫ltimos 5 segundos (janela menor para ser mais preciso)
            local currentTime = os.time()
            for i = #recentAttackers, 1, -1 do
                if currentTime - recentAttackers[i].time > 5 then
                    table.remove(recentAttackers, i)
                end
            end
            
            print("DEBUG: Total de atacantes recentes: " .. #recentAttackers)
        end
        

    end
end)

-- MACRO 3: Detec√ß√£o autom√°tica de morte
macro(1000, function() -- Executa a cada 1 segundo
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    local currentHP = player:getHealthPercent()
    
    -- Se HP chegou a 0 (morte)
    if currentHP == 0 and not isDead then
        isDead = true
        
        -- Determinar causa da morte baseada no server log
        local deathCause = "Desconhecida"
        
        print("DEBUG: Morte detectada! Total de atacantes recentes: " .. #recentAttackers)
        print("DEBUG: √öltimas 10 linhas do server log:")
        for i, line in ipairs(serverLogBuffer) do
            print("DEBUG: " .. i .. ": " .. line)
        end
        
        -- Nova l√≥gica: Analisar as √∫ltimas 10 linhas do server log
        local lastDamages = {}
        for i = #serverLogBuffer, 1, -1 do
            local line = serverLogBuffer[i]
            local damage, attackerName = line:match("You lose (%d+) hitpoints due to an attack by ([^.]+)")
            if attackerName then
                table.insert(lastDamages, {damage = tonumber(damage), attacker = attackerName})
            end
        end
        
        if #lastDamages > 0 then
            -- Pegar o √∫ltimo dano (mais recente)
            local lastDamage = lastDamages[1] -- Primeiro da lista (mais recente)
            deathCause = lastDamage.attacker
            
            if #lastDamages > 1 then
                deathCause = lastDamage.attacker .. " (√∫ltimo dano)"
            end
        else
            -- Fallback: verificar criaturas pr√≥ximas se n√£o houver dados do server log
            local nearbyCreatures = {}
            for _, creature in ipairs(getSpectators()) do
                if (creature:isMonster() or creature:isPlayer()) and creature ~= player and getDistanceBetween(player:getPosition(), creature:getPosition()) <= 3 then
                    table.insert(nearbyCreatures, creature:getName())
                end
            end
            
            if #nearbyCreatures == 1 then
                deathCause = nearbyCreatures[1]
            elseif #nearbyCreatures > 1 then
                deathCause = nearbyCreatures[1] .. " (+" .. (#nearbyCreatures - 1) .. " outros)"
            end
        end
        
        local data = {
            title = 'Personagem Morreu!',
            name = player:getName(),
            message = string.format('**üíÄ Personagem Morreu!**\n\n**üìä Informa√ß√µes:**\n‚Ä¢ Level: %d\n‚Ä¢ Servidor: %s\n‚Ä¢ Posi√ß√£o: %s\n‚Ä¢ Morto por: %s', 
                player:getLevel(), 
                getServerInfo(),
                formatPosition(player:getPosition()),
                deathCause),
            id = "death",
            delayed = 300, -- 5 minutos
            color = 0xFF0000 -- Vermelho
        }
        sendDiscordWebhook(data)
    end
    
    -- Se HP voltou a subir (ressuscitou)
    if currentHP > 0 and isDead then
        isDead = false
        recentAttackers = {} -- Limpar lista de atacantes
        -- N√ÉO reiniciar levelStartTime - manter contagem do level atual
    end
    
    lastHP = currentHP
end)

-- Vari√°vel para controlar se j√° foi inicializado
local systemInitialized = false

-- MACRO 4: Inicializa√ß√£o (primeiro status)
macro(5000, function() -- Executa ap√≥s 5 segundos
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    -- Verificar se j√° foi inicializado
    if systemInitialized then return end
    
    -- Definir level inicial
    lastLevel = player:getLevel()
    levelStartTime = os.time() -- Iniciar contagem do level atual
    
    -- Enviar primeiro status
    local data = {
        title = 'Sistema Iniciado',
        name = player:getName(),
        message = string.format('**üöÄ Sistema Tadala Iniciado!**\n\n**üìä Informa√ß√µes:**\n‚Ä¢ Level: %d\n‚Ä¢ Servidor: %s\n‚Ä¢ Sistema autom√°tico ativo!', 
            player:getLevel(), getServerInfo()),
        id = "init",
        delayed = 0,
        color = 0x0099FF -- Azul
    }
    sendDiscordWebhook(data)
    
    -- Marcar como inicializado
    systemInitialized = true
end)

-- Interface do usu√°rio (apenas informativa)
UI.Separator()
UI.Label("Tadala Discord ON")
UI.Separator()


print("Tadala Discord: Sistema ativo!  by SouledScripts") 











